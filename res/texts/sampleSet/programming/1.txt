First, breadth: A strong software engineer should have a basic level of comfort -- that is, be able to understand code and write something nontrivial -- in these languages:

    C for general familiarity with systems programming, and understanding how compilers, memory management, and the stack work.
    C++ because any programmer who works with C should also, as a practical matter, know C++, and the values and drawbacks of its features relative to C. Performance-sensitive or large-scale data processing (such as code at Google, Facebook, or most other serious tech companies) is still often best written in (a subset of) C++ [1]. It also teaches some useful facts about messy topics like code generation (templates) and multiple inheritance.
    Python or Ruby for familiarity with mainstream, modern scripting languages. Dynamic typing, metaprogramming, rapid prototyping, and Web-oriented development are all easily learned with either of these languages. (Avoid debates on which is better [2,3]. They are both good to know, and more similar than they are different.)
    JavaScript because you can't be a well-rounded developer without knowing basic Web development. It's an interesting language in itself, albeit with numerous flaws, and not all that different from Python or Ruby. It is no longer just a browser-side language, since  Node.js and JavaScript engines are being developed rapidly and used in many new situations.
    Java or C# for mainstream, modern, imperative, garbage-collected languages. Development in a higher-level, more modern language like these is not just popular, but stylistically different enough from C++ that you probably shouldn't avoid learning it. Java especially can introduce you to heavyweight, enterprise-style development (for better and for worse [4,5]). They acquaint you with extensive sets of libraries that are good to know about, so you don't waste time building things that already exist. For extra credit, or if you somehow don't find yourself learning enough of these more these businesslike languages, you might consider instead spending time on Go (or even Rust) as well, as momentum is finally building toward these more modern, concurrency-friendly languages.
    Bash, at least at a basic level. This includes use of common Unix/Linux command-line tools like ls, grep, and sort. This is needed to be proficient in general problem-solving, debugging, and quick data processing on any Linux system. Without this, you may find yourself taking hours or more on something a hacker familiar with Bash could do in minutes [6,7,8].
    At least one or two other languages of a different family. It doesn't matter if they are popular or esoteric, but you should have familiarity with functional languages (Lisp, Scheme, Clojure, etc.) and with type inference (ML, OCaml, Haskell, Scala), and ideally with more specialized languages (Prolog, Erlang, XSLT, etc.). Mathematical and statistical tools like Mathematica, Matlab, R, or Maple are also good. Some might say this isn't important since industry doesn't use these languages broadly, but it improves your understanding of programming enough that it can make a big difference in the long run.


Obviously, that's a lot, but moderate knowledge in each listed bucket is sufficient.

Now depth: You should also know one or two of the languages above at a deeper level. This would mean you have read and written a large amount of code in that language, know its subtleties, and have worked with or read the code of people who have expert-level proficiency in it. This also means knowing something of how the language internals work -- at least look at code for the language's compilers or interpreters, for its built-in libraries, and (if applicable) its native bytecode or assembly output [9].

Also, although these are not usually called programming languages, a good programmer should also know database/query languages, formatting languages, and data formats. Minimally: SQL, HTML, CSS, JSON, XML, and regular expressions.

A few other languages are important but less essential:

    Objective C and now Swift are required for developing on the iOS ecosystem, so for some people they are essential. If you're building iPad or iPhone apps, you'll learn them. If you're doing most anything else, you won't have any real reason to.
    PHP is still the most popular server-side Web development language. However, it's not in the essential list above, simply because it's not a good first language due to its poor design and shortcomings, and because once you know Python or Ruby, it is not too difficult to pick up.
    Perl has a venerable history and arguably is still the quickest tool for certain small tasks. It's also fairly fast compared to Python/Ruby. However, it is a poor choice in most situations due to its age, poor readability, and dwindling mind-share.


Solid experience in all of this takes a while, but it's one of those situations where being ahead keeps you ahead. Once you have breadth and depth, you'll be stronger and more flexible than most professional programmers, which will help you find better and more challenging programming jobs, which will allow you to learn from the work and from others and keep improving your skills quickly.