<script src="./Chart.bundle.js"></script>
<div id="canvas-holder" style="width:50%">
    <canvas id="canvas" width="800" height="600" style="border-style: solid"></canvas>
    <button id="cleanCanvas">Clean</button>
    <button id="done">Done</button>
</div>
<div>
    <canvas id="chart-area"></canvas>
</div>
<script type="text/javascript">

window.chartColors = {
    red: 'rgb(255, 99, 132)',
    orange: 'rgb(255, 159, 64)',
    yellow: 'rgb(255, 205, 86)',
    green: 'rgb(75, 192, 192)',
    blue: 'rgb(54, 162, 235)',
    purple: 'rgb(153, 102, 255)',
    grey: 'rgb(201, 203, 207)',
    lime: 'rgb(128, 128, 0)',
    brown: 'rgb(170, 110, 40)',
    mint: 'rgb(170, 255, 195)'
};

var TimeIntervals = function(){
    this.lastTime = new Date().getTime();

    this.currentInterval = function() {
        var newTime = new Date().getTime();
        var interval = newTime - this.lastTime;
        this.lastTime = newTime;
        return interval;
    }
}

var canvas = document.getElementById('canvas');
var context = canvas.getContext("2d");
var cleanButton = document.getElementById('cleanCanvas');
var doneButton = document.getElementById('done');
var timeIntervals;

cleanButton.addEventListener("click", function(e) {
    clean();
})

doneButton.addEventListener("click", function(e) {
    statictic(true);
    clean();
})

canvas.addEventListener("mousedown", function(e) {
    var mouseX = e.pageX - this.offsetLeft;
    var mouseY = e.pageY - this.offsetTop;
    if (times.length == 0) {
        timeIntervals = new TimeIntervals();
    }
    var time = timeIntervals.currentInterval();
    paint = true;
    addClick(e.pageX - this.offsetLeft, e.pageY - this.offsetTop, false, time);
    redraw();
});

canvas.addEventListener("mousemove", function(e) {
    if (paint) {
        var time = timeIntervals.currentInterval();
        addClick(e.pageX - this.offsetLeft, e.pageY - this.offsetTop, true, time);
        redraw();
    }
});

canvas.addEventListener("mouseup", function(e) {
    paint = false;
});

canvas.addEventListener("mouseleave", function(e) {
    paint = false;
});

var clickX = new Array();
var clickY = new Array();
var clickDrag = new Array();
var times = new Array();
var paint;
var length = 0;

function addClick(x, y, dragging, time) {
    clickX.push(x);
    clickY.push(y);
    clickDrag.push(dragging);
    times.push(time);
    statictic();
}

function redraw() {
    context.clearRect(0, 0, context.canvas.width, context.canvas.height); // Clears the canvas

    context.strokeStyle = "#df4b26";
    context.lineJoin = "round";
    context.lineWidth = 5;

    for (var i = 0; i < clickX.length; i++) {
        context.beginPath();
        if (clickDrag[i] && i) {
            context.moveTo(clickX[i - 1], clickY[i - 1]);
        } else {
            context.moveTo(clickX[i] - 1, clickY[i]);
        }
        context.lineTo(clickX[i], clickY[i]);
        context.closePath();
        context.stroke();
    }
}

function clean(){
    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    clickX = new Array();
    clickY = new Array();
    clickDrag = new Array();
    times = new Array();
    statictic();
}

Array.prototype.max = function() {
    return Math.max.apply(null, this);
};

Array.prototype.last = function() {
    return this[this.length-1];
};

Array.prototype.min = function() {
    return Math.min.apply(null, this);
};

Array.prototype.sum = function() {
    return this.reduce(function(a, b) {return a + b;}, 0);
};

function statictic(verbose) {
    var timer = times.sum();
    var lines = clickDrag.filter(function(a){return a==false;}).length
    var min_x = clickX.min();
    var min_y = clickY.min();
    var max_x = clickX.max();
    var max_y = clickY.max();
    var horizontalLength = max_y - min_y;
    var verticalLength = max_x - min_x;
    var square = horizontalLength * verticalLength;
    var dists = distances(clickX, clickY, clickDrag);
    var totalLength = dists.sum();
    var velocities = dists.map(function(currentValue, index){ return currentValue / times[index];}).filter(function(x){return x != 0 && !isNaN(x);});
    var maxVelocity = velocities.max();
    var minVelocity = velocities.min();
    var durationX = getDuration(clickX, times);
    var durationY = getDuration(clickY, times);
    if(verbose){
        console.log(timer , lines,  square, horizontalLength, verticalLength, totalLength, maxVelocity, minVelocity, durationX, durationY);
    }
    updateChart(timer , lines, square, horizontalLength, verticalLength, totalLength, maxVelocity, minVelocity, durationX, durationY);
}

function distances(clickX, clickY, clickDrag){
    var dist = new Array();
    for (var i = 0; i < clickX.length; i++) {
        if (clickDrag[i]) {
            var deltaX = clickX[i-1] - clickX[i];
            var deltaY = clickY[i-1] - clickY[i];
            var distance = Math.sqrt((deltaX * deltaX) + (deltaY * deltaY));
            dist.push(distance);
        }
        else{
           dist.push(0)     
        }
    }
    return dist;
}

function getDuration(coordinates, times){
    var total = 0;
    for (var i = 1; i < coordinates.length - 1; i++) {
        if (coordinates[i-1] - coordinates[i] != 0) {
            total+=times[i];
        }
    }
    return total;
}

var chartColors = window.chartColors;
var color = Chart.helpers.color;
var config = {
    data: {
        datasets: [{
            data: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ],
            backgroundColor: [
                color(chartColors.red).alpha(0.5).rgbString(),
                color(chartColors.orange).alpha(0.5).rgbString(),
                color(chartColors.yellow).alpha(0.5).rgbString(),
                color(chartColors.green).alpha(0.5).rgbString(),
                color(chartColors.blue).alpha(0.5).rgbString(),
                color(chartColors.purple).alpha(0.5).rgbString(),
                color(chartColors.grey).alpha(0.5).rgbString(),
                color(chartColors.brown).alpha(0.5).rgbString(),
                color(chartColors.mint).alpha(0.5).rgbString(),
            ],
            label: 'My dataset'
        }],
        labels: [
            "Time",
            "Lines",
            "Square",
            "Horizontal Length",
            "Vertical Length",
            "Total Length",
            "Max Velocity",
            "Min Velocity",
            "Duration by X",
            "Duration by Y"
        ]
    },
    options: {
        responsive: true,
        legend: {
            position: 'right',
        },
        title: {
            display: true,
            text: 'Sign params'
        },
        scale: {
            ticks: {
                beginAtZero: true
            },
            reverse: false
        },
        animation: {
            animateRotate: false,
            animateScale: true
        }
    }
};

window.onload = function() {
    var ctx = document.getElementById("chart-area");
    window.myPolarArea = Chart.PolarArea(ctx, config);
};

function updateChart(timer , lines, square, horizontalLength, verticalLength, totalLength, maxVelocity, minVelocity, durationX, durationY) {
    config.data.datasets[0].data[0] = timer / 1000;
    config.data.datasets[0].data[1] = lines;
    config.data.datasets[0].data[2] = square / 10000;
    config.data.datasets[0].data[3] = horizontalLength / 100;
    config.data.datasets[0].data[4] = verticalLength / 100;
    config.data.datasets[0].data[5] = totalLength / 1000;
    config.data.datasets[0].data[6] = maxVelocity;
    config.data.datasets[0].data[7] = minVelocity * 1000;
    config.data.datasets[0].data[8] = durationX / 1000;
    config.data.datasets[0].data[9] = durationY / 1000;
    window.myPolarArea.update();
}
</script>